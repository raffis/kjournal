package install

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"path"
	"time"

	securejoin "github.com/cyphar/filepath-securejoin"

	"github.com/raffis/kjournal/cli/pkg/manifestgen"
)

// Generate returns the install manifests as a multi-doc YAML.
// The manifests are built from a GitHub release or from a
// Kustomize overlay if the supplied Options.BaseURL is a local path.
// The manifestsBase should be set to an empty string when Generate is
// called by consumers that don't embed the manifests.
func Generate(options Options, manifestsBase string) (*manifestgen.Manifest, error) {
	/*ctx, cancel := context.WithTimeout(context.Background(), options.Timeout)
	defer cancel()
	*/
	var err error

	output, err := securejoin.SecureJoin(manifestsBase, options.ManifestFile)
	if err != nil {
		return nil, err
	}

	/*if !strings.HasPrefix(options.BaseURL, "http") {
		if err := build(options.BaseURL, output); err != nil {
			return nil, err
		}
	} else {*/
	// download the manifests base from GitHub
	if manifestsBase == "" {
		manifestsBase, err = manifestgen.MkdirTempAbs("", options.Namespace)
		if err != nil {
			return nil, err
		}

		defer os.RemoveAll(manifestsBase)
		output, err = securejoin.SecureJoin(manifestsBase, options.ManifestFile)
		if err != nil {
			return nil, err
		}
	}

	if err := generate(manifestsBase, options); err != nil {
		return nil, err
	}

	if options.AsKustomization {
		output, err = securejoin.SecureJoin(manifestsBase, "kustomization.yaml")
		if err != nil {
			return nil, err
		}
	} else {
		if err := build(manifestsBase, output); err != nil {
			return nil, err
		}
	}

	content, err := os.ReadFile(output)
	if err != nil {
		return nil, err
	}

	return &manifestgen.Manifest{
		Path:    path.Join(options.TargetPath, options.Namespace, options.ManifestFile),
		Content: fmt.Sprintf("%s\n%s", GetGenWarning(options), string(content)),
	}, nil
}

// GetLatestVersion calls the GitHub API and returns the latest released version.
func GetLatestVersion() (string, error) {
	ghURL := "https://api.github.com/repos/raffis/kjournal/releases/latest"
	c := http.DefaultClient
	c.Timeout = 15 * time.Second

	res, err := c.Get(ghURL)
	if err != nil {
		return "", fmt.Errorf("GitHub API call failed: %w", err)
	}

	if res.Body != nil {
		defer res.Body.Close()
	}

	type meta struct {
		Tag string `json:"tag_name"`
	}
	var m meta
	if err := json.NewDecoder(res.Body).Decode(&m); err != nil {
		return "", fmt.Errorf("decoding GitHub API response failed: %w", err)
	}

	return m.Tag, err
}

// GetGenWarning generates a consistent generation warning in the install case in the following format:
// # This manifest was generated by kjournal. DO NOT EDIT.
// # kjournal version: v0.0.1
func GetGenWarning(options Options) string {
	return fmt.Sprintf("---\n%s\n# kjournal Version: %s", manifestgen.GenWarning, options.Version)
}
