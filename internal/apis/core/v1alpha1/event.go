package v1alpha1

import (
	"context"
	"encoding/json"
	"fmt"
	"unsafe"

	"github.com/raffis/kjournal/pkg/apis/core/v1alpha1"
	v1 "k8s.io/api/core/v1"
	eventsv1 "k8s.io/api/events/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/conversion"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/types"
)

type EventList struct {
	v1alpha1.EventList
	Items []Event `json:"items"`
}

type Event struct {
	v1alpha1.Event
}

func (in *Event) UnmarshalJSON(bs []byte) error {
	coreEvent := &v1.Event{}
	err := json.Unmarshal(bs, coreEvent)
	if err != nil {
		return nil
	}

	return Convert_core_Event_To_v1_Event(coreEvent, &in.Event.Event, nil)
}

func (in *Event) New() runtime.Object {
	return &Event{}
}

func (in *Event) NewList() runtime.Object {
	return &EventList{}
}

func (in *Event) asCells() []interface{} {
	return []interface{}{in.ObjectMeta.CreationTimestamp, in.Type, in.Reason, fmt.Sprintf("%s/%s", in.Regarding.Kind, in.Regarding.Name), in.Note}
}

var eventTableColums = []metav1.TableColumnDefinition{
	{Name: "LAST SEEN", Type: "", Format: "name", Description: "s"},
	{Name: "TYPE", Type: "string", Format: "name", Description: "s"},
	{Name: "REASON", Type: "string", Description: "The reference to the service that hosts this API endpoint."},
	{Name: "OBJECT", Type: "string", Description: "Whether this service is available."},
	{Name: "MESSAGE", Type: "string", Description: "Whether this service is available."},
}

// ConvertToTable implements the TableConvertor interface for REST.
func (in *Event) ConvertToTable(ctx context.Context, tableOptions runtime.Object) (*metav1.Table, error) {
	table := &metav1.Table{
		ColumnDefinitions: eventTableColums,
		TypeMeta:          in.TypeMeta,
	}

	rows := make([]metav1.TableRow, 0, 1)
	row := metav1.TableRow{
		Object: runtime.RawExtension{Object: in},
		Cells:  in.asCells(),
	}

	rows = append(rows, row)
	table.Rows = rows
	return table, nil
}

// ConvertToTable implements the TableConvertor interface for REST.
func (in *EventList) ConvertToTable(ctx context.Context, tableOptions runtime.Object) (*metav1.Table, error) {
	table := &metav1.Table{
		ColumnDefinitions: eventTableColums,
		TypeMeta:          in.TypeMeta,
	}

	rows := make([]metav1.TableRow, 0, 1)

	for _, v := range in.Items {
		item := &v
		row := metav1.TableRow{
			Object: runtime.RawExtension{Object: item},
			Cells:  v.asCells(),
		}
		fmt.Printf("\nITEM %#v\n", item)
		rows = append(rows, row)
	}

	table.Rows = rows
	return table, nil
}

func autoConvert_core_Event_To_v1_Event(in *v1.Event, out *eventsv1.Event, s conversion.Scope) error {
	out.ObjectMeta = in.ObjectMeta
	out.Reason = in.Reason
	out.Type = in.Type
	out.EventTime = in.EventTime
	out.Series = (*eventsv1.EventSeries)(unsafe.Pointer(in.Series))
	out.Action = in.Action
	out.Related = (*v1.ObjectReference)(unsafe.Pointer(in.Related))
	out.ReportingController = in.ReportingController
	out.ReportingInstance = in.ReportingInstance
	return nil
}

func autoConvert_core_EventSource_To_v1_EventSource(in *v1.EventSource, out *v1.EventSource, s conversion.Scope) error {
	out.Component = in.Component
	out.Host = in.Host
	return nil
}

// Convert_core_EventSource_To_v1_EventSource is an autogenerated conversion function.
func Convert_core_EventSource_To_v1_EventSource(in *v1.EventSource, out *v1.EventSource, s conversion.Scope) error {
	return autoConvert_core_EventSource_To_v1_EventSource(in, out, s)
}

func autoConvert_core_ObjectReference_To_v1_ObjectReference(in *v1.ObjectReference, out *v1.ObjectReference, s conversion.Scope) error {
	out.Kind = in.Kind
	out.Namespace = in.Namespace
	out.Name = in.Name
	out.UID = types.UID(in.UID)
	out.APIVersion = in.APIVersion
	out.ResourceVersion = in.ResourceVersion
	out.FieldPath = in.FieldPath
	return nil
}

// Convert_core_ObjectReference_To_v1_ObjectReference is an autogenerated conversion function.
func Convert_core_ObjectReference_To_v1_ObjectReference(in *v1.ObjectReference, out *v1.ObjectReference, s conversion.Scope) error {
	return autoConvert_core_ObjectReference_To_v1_ObjectReference(in, out, s)
}

func Convert_core_Event_To_v1_Event(in *v1.Event, out *eventsv1.Event, s conversion.Scope) error {
	if err := autoConvert_core_Event_To_v1_Event(in, out, s); err != nil {
		return err
	}
	if err := Convert_core_ObjectReference_To_v1_ObjectReference(&in.InvolvedObject, &out.Regarding, s); err != nil {
		return err
	}
	if err := Convert_core_EventSource_To_v1_EventSource(&in.Source, &out.DeprecatedSource, s); err != nil {
		return err
	}
	out.Note = in.Message
	out.DeprecatedFirstTimestamp = in.FirstTimestamp
	out.DeprecatedLastTimestamp = in.LastTimestamp
	out.DeprecatedCount = in.Count
	return nil
}

func AddFieldLabelConversionsForEvent(scheme *runtime.Scheme) error {
	var SchemeGroupVersion = schema.GroupVersion{Group: "core.kjournal", Version: "v1alpha1"}
	mapping := map[string]string{
		"reason":                    "reason",
		"regarding.kind":            "involvedObject.kind",            // map events.k8s.io field to fieldset returned by ToSelectableFields
		"regarding.namespace":       "involvedObject.namespace",       // map events.k8s.io field to fieldset returned by ToSelectableFields
		"regarding.name":            "involvedObject.name",            // map events.k8s.io field to fieldset returned by ToSelectableFields
		"regarding.uid":             "involvedObject.uid",             // map events.k8s.io field to fieldset returned by ToSelectableFields
		"regarding.apiVersion":      "involvedObject.apiVersion",      // map events.k8s.io field to fieldset returned by ToSelectableFields
		"regarding.resourceVersion": "involvedObject.resourceVersion", // map events.k8s.io field to fieldset returned by ToSelectableFields
		"regarding.fieldPath":       "involvedObject.fieldPath",       // map events.k8s.io field to fieldset returned by ToSelectableFields
		"reportingController":       "reportingComponent",             // map events.k8s.io field to fieldset returned by ToSelectableFields
		"type":                      "type",
		"metadata.namespace":        "metadata.namespace",
		"metadata.name":             "metadata.name",
	}
	return scheme.AddFieldLabelConversionFunc(SchemeGroupVersion.WithKind("Event"),
		func(label, value string) (string, string, error) {
			mappedLabel, ok := mapping[label]
			if !ok {
				return "", "", fmt.Errorf("field label not supported: %s", label)
			}
			return mappedLabel, value, nil
		},
	)
}
